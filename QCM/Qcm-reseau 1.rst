.. raw:: html

  <script type="text/javascript" src="js/jquery-1.7.2.min.js"></script>
  <script type="text/javascript" src="js/jquery-shuffle.js"></script>
  <script type="text/javascript" src="js/rst-form.js"></script>
  <script type="text/javascript">$nmbr_prop = 4</script>


=========================
Mission X : The Network Layer, Principles
=========================

Ces questions ont pour objectif de vous permettre de tester vous-même votre compréhension de la matière couverte par cette mission de mise en route.

Ces questions supposent que vous avez lu le cinquième chapitre du syllabus contenant l'introduction à la Network Layer.


Question 1. Shortest Path Tree
------------------------------

Analyse the network given. What is the shortest path tree for the router A?

  .. figure:: ../png/qcm1-1.png
     :align: center
     :scale: 100

.. class:: positive

-
  .. figure:: ../png/Q1-solution1.png 
     :align: center
     :scale: 100
  
-
  .. figure:: ../png/Q1-solution2.png 
     :align: center
     :scale: 100

.. class:: negative

-
 .. figure:: ../png/Q1-mauvais1.png 
     :align: center
     :scale: 100
-
 .. figure:: ../png/Q1-mauvais2.png 
     :align: center
     :scale: 100
 
 .. class:: comment


Question 2. Distance vector routing
-----------------------------

The routers from question 1 uses distance vector routing. They sends their distance vector regularly over all theirs interfaces. Wich one of these 
sequences of message could have been generated by the network from question 1?

.. class:: positive

-
  - [D=0]
  - [A=0, D=10]
  - [B=0]
  - [C=0, A=3, D=3]
  - [E=0, A=8, B=4, C=5, D=5]
  - [D=0, A=6, B=9, C=3, E=5]
  - [B=0, A=4, C=9, E=4, D=9]
  - [A=0, B=4, C=3, D=6, E=8]


-
  - [C=0]
  - [A=0, C=3]
  - [D=0, C=3, A=10]
  - [E=0, A=15, C=5, D=5]
  - [B=0, A=4, E=4, C=9, D=9]
  - [C=0, A=3, D=3, E=5]
  - [E=0, A=8, C=5, D=5, B=4]
  - [A=0, B=4, C=3, D=6, E=8]


.. class:: negative

-
  - [B=0]
  - [C=0]
  - [D=0, C=3]
  - [A=0, B=4, C=3, D=10]
  - [E=0, C=5, B=4, D=5]
  - [D=0, A=6, B=9, C=3, E=5]
  - [B=0, A=4, C=9, E=4, D=9]
  - [A=0, B=4, C=3, D=6, E=8]
  - [C=0, A=3, D=3, E=5, B=9]


-
  - [D=0]
  - [A=0, D=10]
  - [B=0]
  - [C=0, A=3, D=3, B=9]
  - [E=0, A=8, B=4, C=5, D=5]
  - [D=0, A=6, B=9, C=3, E=5]
  - [B=0, A=4, C=9, E=4, D=9]
  - [A=0, B=4, C=3, D=6, E=8]

-
  - [C=0]
  - [A=0, C=3]
  - [D=0, C=3, A=6]
  - [E=0, A=8, C=5, D=5]
  - [B=0, A=4, E=4, C=9, D=9]
  - [C=0, A=3, D=3, E=5]
  - [E=0, A=8, C=5, D=5, B=4]
  - [A=0, B=4, C=3, D=6, E=8]


  .. class:: comment

     Read Computer Networking : Principles, Protocols and Practice section 5.1.2 : The control plane.




Question 3. Failure with Distance Vector Routing
--------------------------------------------------------------

Consider that the network reach a state where the router A, C, D have receive
distance vector from each of them. For an unknow reason, these routers have
never heard about B and E. Then, the link between the router A and D fail. What
will happen ?

 .. figure:: ../png/qcm1-3.png 
     :align: center
     :scale: 100
 
.. class:: positive

- Routers A and D notice after a sufficient delay (How much ?) that they own a route which
  is too old. The next distance vector for A will be [ TODO ] and the next
  distance vector for D will be [ TODO ].


.. class:: negative

- Routers A and D notice after a sufficient delay (How much ?) that they own a route which
  is too old. The next distance vector for A will be [ TODO B=inf, E=inf ] and the next
  distance vector for D will be [ TODO B=inf, E=inf ].


- Either router A or router D notice first the failure (let's say that A notice
  first) and sent its vector routing to the others with inside C=inf. When router C receive 

.. class:: comment

      En C, contrairement à Java, la fonction ``main`` retourne une valeur de type ``int``.

-
 .. code:: c

    int main(int argc, const char *argv[]) {
        printf("Hello, world\n");
    }


 .. class:: comment

       La fonction `printf(3)`_ utilisée par ce programme fait partie de la librairie standard de gestion des I/O. Pour l'utiliser, il faut inclure le header `stdio.h`_. Même si certains compilateurs pouvaient l'inclure par défaut, il est préférable de spécifier ce header explicitement.

-
 .. code:: c

    #include <stdlib.h>
    int main() {
        printf("Hello, world\n");
    }


 .. class:: comment

    En C, la signature de la fonction ``main`` est ``int main(int argc, const char *argv[])`` même si certains compilateurs peuvent être tolérants. `printf(3)`_ est défini via `stdio.h`_ et non `stdlib.h`_.

-
 .. code:: c

    #include <stdlib.h>
    void main()
        printf("Hello, world\n");
    }


 .. class:: comment

    En C, la signature de la fonction ``main`` est ``int main(int argc, const char *argv[])`` même si certains compilateurs peuvent être tolérants. `printf(3)`_ est défini via `stdio.h`_ et non `stdlib.h`_.


Question 4. Link State Routing
-------------------------------------------

Link state routing is the second type of routing protocols. When a router use link state routing, it sends message on the network. Wich of theses affirmations are corrects?

.. class:: positive

-
    A link state router sends periodically a HELLO message to all it's neighbourgs.

-
    A link-state router sends link-state packets to its neighbours. If this lsp is newer than the one stored in the link state database of the neighbours, they forwards the lsp on all links except the one over which the LSP was received.

-
    The Link state packet send by a router contains information only about the neighbours of this router.

.. class:: negative

-
    A link state router sends periodically a HELLO message to all it's neighbourgs. This HELLO message is forwarded all over the network.

-
    A link state router sends a HELLO message once when it boots.

-
    A link-state router sends link-state packets only to its neighbours. (They are not forwarded further)

-
    When flooding is used on a network, there is a link state database containing the most recent LSP sent by each router shared between all routers. 

 .. class:: comment

    En C, la fonction `printf(3)`_ prend un nombre variable d'arguments. Le premier est toujours une spécification de formatage qui indique la chaîne de caractères à afficher. Les autres arguments sont des identifiants de variables dont les valeurs seront utilisées pour construire la chaîne de caractères à afficher. Le deuxième argument remplace le premier format `%d`, le troisième argument le deuxième format, etc. La page de manuel de `printf(3)`_ fournit de nombreux détails sur le fonctionnement de cette fonction qui accepte de nombreux paramètres.

-
 .. code:: c

    #include <stdlio.h>
    int main(int argc, const char *argv[]) {
        int a = 1252;
        printf("SINF");
	printf("%d\n", a);
    }

 .. class:: comment

    En C, la fonction `printf(3)`_ prend un nombre variable d'arguments. Le premier est toujours une spécification de formatage qui indique la chaîne de caractères à afficher. Les autres arguments sont des identifiants de variables dont les valeurs seront utilisées pour construire la chaîne de caractères à afficher. Le deuxième argument remplace le premier format `%d`, le troisième argument le deuxième format, etc. La page de manuel de `printf(3)`_ fournit de nombreux détails sur le fonctionnement de cette fonction qui accepte de nombreux paramètres.

.. class:: negative

-
 .. code:: c

    #include <stdlio.h>
    int main(int argc, const char *argv[]) {
        int a = 1252;
        printf("SINF%a\n", a);
    }

 .. class:: comment

    Dans la fonction `printf(3)`_, ``%a`` est utilisé lorsque l'on veut placer dans une chaîne de caractères un nombre réel en notation hexadécimale. Dans ce cas, ``a`` étant un entier, il aurait fallu utiliser ``%d``.

-
 .. code:: c

    #include <stdlio.h>
    int main(int argc, const char *argv[]) {
        int a = 1252;
        printf(SINF);
	printf(%d\n, a);
    }

 .. class:: comment

    En C, une chaîne de caractères (ou un descripteur de format pour `printf(3)`_ qui est aussi une chaîne de caractères) commence et se termine par le caractère ``"``.

-
 .. code:: c

    #include <stdlio.h>
    int main(int argc, const char *argv[]) {
        int a = 1252;
        printf("SINF$a\n", a);
    }

 .. class:: comment

    Dans la fonction `printf(3)`_ en C, et contrairement à d'autres langages, le caractère ``$`` ne joue pas de rôle particulier. Le programme ci-dessus affichera donc simplement ``SINF$a`` à l'écran.


Question 5. Arguments passés à un programme C
---------------------------------------------

Considérons le programme C ci-dessous qui permet de manipuler les arguments passés en ligne de commande.

        .. code-block:: c

                #include <stdlio.h>
                #include <stdlib.h>
                int main(int argc, const char *argv[])
                {
                        int a = atoi(argv[1]);
                        printf("%d\n", a);
                }

Parmi les groupes d'affirmations ci-dessous, un seul ne contient que des affirmations qui sont toutes vraies. Lequel ?


.. class:: positive

-

  - Lors de l'exécution de la fonction ``main``, ``argc`` est initialisé au nombre d'arguments passés au programme (y compris le nom de l'exécutable lui-même).
  - Lors de l'exécution de la fonction ``main``, le tableau ``argv[]`` contient dans ```argv[0]`` le nom du programme, dans ``argv[1]`` le premier argument, etc.
  - La fonction ``atoi`` permet de convertir une chaîne de caractères en l'entier équivalent.


.. class:: negative

-
  - Lors de l'exécution de la fonction ``main``, ``argc`` est initialisé à zéro.
  - Lors de l'exécution de la fonction ``main``, le tableau ``argv[]`` contient dans ``argv[0]`` le premier argument, dans ``argv[1]`` le second argument, etc.
  - La fonction ``atoi`` calcule la taille de son argument.

  .. class:: comment

     Les trois affirmations sont fausses. ``argc`` sera toujours initialisé à un vu que le nom du programme est toujours passé en argument. Le premier élément du tableau ``argv[]``, ``argv[0]``, est le nom du programme qui est exécuté. Enfin, la fonction ``atoi`` permet de convertir une chaîne de caractères en l'entier équivalent.

-
  - Lors de l'exécution de la fonction ``main``, ``argc`` est le nombre maximum d'arguments que l'on peut lui passer.
  - Lors de l'exécution de la fonction ``main``, le tableau ``argv[]`` contient dans ``argv[0]`` le premier argument, dans ``argv[1]`` le second argument, etc.
  - La fonction ``atoi`` doit prendre comme argument une chaîne de caractères qui ne contient que des chiffres.

  .. class:: comment

     Les deux premières affirmations sont fausses. ``argc`` contient le nombre d'arguments passés effectivement au programme. Le premier élément du tableau ``argv[]``, ``argv[0]``, est le nom du programme qui est exécuté.

-
  - Lors de l'exécution de la fonction ``main``, le tableau ``argv[]`` contient dans ```argv[0]`` le premier argument, dans ``argv[1]`` le second argument, etc.
  - La fonction ``atoi`` permet de convertir une chaîne de caractères en l'entier équivalent.

  .. class:: comment

     Le premier élément du tableau ``argv[]``, ``argv[0]``, est le nom du programme qui est exécuté.

.. include:: ../../../links.rst
.. include:: ../../../man_links.rst
.. include:: ../../../incl_links.rst
